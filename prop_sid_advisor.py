import argparse
import base64
import json
from datetime import datetime, timedelta
from pathlib import Path

import MetaTrader5 as mt5
import pandas as pd
import pandas_ta_classic
import plotly.graph_objects as go
import resend
from plotly.subplots import make_subplots

from config import *

# --- INITIALIZATION ---
load_dotenv()
resend.api_key = os.getenv("RESEND_API_KEY")
EMAIL_SENDER = os.getenv("RESEND_EMAIL_FROM")
EMAIL_RECEIVER = os.getenv("EMAIL_RECEIVER").split(',')


def initialize_mt5():
    login = int(os.getenv("MT5_LOGIN"))
    password = os.getenv("MT5_PASSWORD")
    server = os.getenv("MT5_SERVER")
    if not mt5.initialize(login=login, password=password, server=server):
        print(f"MT5 Init Failed: {mt5.last_error()}")
        return False
    return True


# --- CORE MT5 FUNCTIONS (IDENTICAL TO BOT) ---

def get_data(ticker):
    rates = mt5.copy_rates_from_pos(ticker, mt5.TIMEFRAME_D1, 0, 100)
    if rates is None or len(rates) < 15: return pd.DataFrame()
    df = pd.DataFrame(rates)
    df['time'] = pd.to_datetime(df['time'], unit='s')
    df.rename(columns={'time': 'timestamp'}, inplace=True)
    return df


def get_symbol_category(symbol):
    info = mt5.symbol_info(symbol)
    if info is None: return "UNKNOWN"
    path = info.path.upper()
    if "XAU" in symbol or "XAG" in symbol: return "METALS"
    if "FOREX" in path: return "FOREX"
    if "STOCK" in path or "EQUITY" in path: return "STOCKS"
    if "INDEX" in path or "INDICES" in path: return "INDICES"
    if "CRYPTO" in path: return "CRYPTO"
    return "FOREX"


def calculate_dynamic_stop(df, ticker, order_type):
    df.ta.atr(length=14, append=True)
    atr = df.iloc[-1][df.columns[df.columns.str.contains('ATR')][-1]]
    curr_price = df['close'].iloc[-1]

    dist = atr * VOLATILITY_MULT.get(get_symbol_category(ticker), 2.0)

    if order_type == mt5.ORDER_TYPE_BUY:
        return min(curr_price - dist, df['low'].tail(3).min())
    else:
        return max(curr_price + dist, df['high'].tail(3).max())


def is_earnings_safe(ticker):
    cache_path = Path(__file__).parent / 'earnings_cache.json'
    if not cache_path.exists(): return False
    with open(cache_path, 'r') as f:
        data = json.load(f)
    if ticker not in data: return True
    days_until = (datetime.strptime(data[ticker], '%Y-%m-%d').date() - datetime.now().date()).days
    return days_until > 14


# --- REPORTING ENGINE ---

def generate_chart(ticker, df):
    fig = make_subplots(rows=3, cols=1, shared_xaxes=True, vertical_spacing=0.05, row_heights=[0.5, 0.25, 0.25])
    fig.add_trace(go.Candlestick(x=df['timestamp'], open=df['open'], high=df['high'], low=df['low'], close=df['close']),
                  row=1, col=1)
    fig.add_trace(go.Scatter(x=df['timestamp'], y=df['RSI_14'], line=dict(color='yellow')), row=2, col=1)

    # Standard MACD columns from pandas_ta
    macd_cols = [c for c in df.columns if 'MACD' in c]
    if len(macd_cols) >= 3:
        fig.add_trace(go.Scatter(x=df['timestamp'], y=df[macd_cols[0]], line=dict(color='cyan')), row=3, col=1)
        fig.add_trace(go.Scatter(x=df['timestamp'], y=df[macd_cols[1]], line=dict(color='orange')), row=3, col=1)
        fig.add_trace(go.Bar(x=df['timestamp'], y=df[macd_cols[2]]), row=3, col=1)

    fig.update_layout(title=f"MT5 Prop Signal: {ticker}", template="plotly_dark", xaxis_rangeslider_visible=False,
                      height=800, showlegend=False)
    img_path = f"{ticker}_mt5.png"
    fig.write_image(img_path)
    return img_path


def send_advisor_email(longs, shorts, sector_stats):
    """Sends reports via Resend API with an educational disclaimer."""

    # 1. Build Signal Report Body
    body_text = "### MT5 PROP SIGNAL ADVISOR: DAILY SCAN ###\n\n"

    body_text += "--- RANKED LONG SIGNALS ---\n"
    if longs:
        for i, l in enumerate(longs):
            body_text += f"{i + 1}. {l['ticker']} | RSI: {l['score']:.1f} | Lots: {l['qty']} | SL: {l['sl']:.5f}\n"
    else:
        body_text += "No Long setups identified.\n"

    body_text += "\n--- RANKED SHORT SIGNALS ---\n"
    if shorts:
        for i, s in enumerate(shorts):
            body_text += f"{i + 1}. {s['ticker']} | RSI: {abs(s['score']):.1f} | Lots: {s['qty']} | SL: {s['sl']:.5f}\n"
    else:
        body_text += "No Short setups identified.\n"

    # 2. Add Educational Disclaimer
    body_text += "\n" + "=" * 50 + "\n"
    body_text += "### EDUCATIONAL USE ONLY - EXPERIMENTAL SYSTEM ###\n"
    body_text += "The picks above are generated by an experimental algorithm and are for educational use only. "
    body_text += "This does not constitute financial or investment advice. Trading involves significant risk, "
    body_text += "and past performance is not indicative of future results. Consult a licensed advisor before trading.\n"
    body_text += "=" * 50

    # 3. Handle Local File Attachments (Base64 required for Resend)
    attachments = []
    for pick in (longs[:3] + shorts[:3]):
        img_path = generate_chart(pick['ticker'], pick['df'].tail(60))
        with open(img_path, "rb") as f:
            content = base64.b64encode(f.read()).decode()
            attachments.append({
                "content": content,
                "filename": f"{pick['ticker']}_setup.png"
            })
        os.remove(img_path)

    # 4. Send via Resend API
    params = {
        "from": EMAIL_SENDER,
        "to": EMAIL_RECEIVER,
        "subject": f"Prop Signal Advisor - {datetime.now().strftime('%Y-%m-%d')}",
        "text": body_text,
        "attachments": attachments
    }

    try:
        resend.Emails.send(params)
        print("âœ… Advisor report sent successfully via Resend.")
    except Exception as e:
        print(f"âŒ Resend API Error: {e}")


# --- ADMIN EMAIL ---
def send_admin_heartbeat():
    """Sends a private email with MT5 equity, drawdown, and recent trade logs."""
    try:
        if not mt5.initialize():
            print("âŒ Heartbeat failed: MT5 not initialized.")
            return

        # 1. Fetch Account Metrics
        account = mt5.account_info()
        if not account:
            print("âŒ Could not retrieve account info.")
            return

        equity = account.equity
        balance = account.balance

        # 2. Calculate Start-of-Day Balance for Drawdown
        # Fetches realized P/L from today's midnight to now
        today_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        history_deals = mt5.history_deals_get(today_start, datetime.now())

        today_realized_pl = 0
        if history_deals:
            for deal in history_deals:
                today_realized_pl += (deal.profit + deal.commission + deal.swap + deal.fee)

        start_of_day_balance = balance - today_realized_pl
        drawdown = (start_of_day_balance - equity) / start_of_day_balance if start_of_day_balance > 0 else 0

        status = "ðŸŸ¢ OPERATIONAL" if drawdown < MAX_DAILY_DRAWDOWN_PCT else "ðŸ”´ PAUSED (DRAWDOWN)"

        # 3. Fetch Trade Log (Deals from last 24 hours)
        last_24h = datetime.now() - timedelta(days=1)
        recent_deals = mt5.history_deals_get(last_24h, datetime.now())

        trade_log = "--- RECENT TRADES (24H) ---\n"
        if recent_deals:
            for d in recent_deals:
                # Filter for actual trades (entry/exit), excluding balance/deposit entries
                if d.entry in [mt5.DEAL_ENTRY_IN, mt5.DEAL_ENTRY_OUT]:
                    deal_time = datetime.fromtimestamp(d.time).strftime('%H:%M')
                    side = "BUY" if d.type == mt5.DEAL_TYPE_BUY else "SELL"
                    trade_log += f"- {deal_time} | {d.symbol} | {side} | {d.volume} @ {d.price} | P/L: ${d.profit:.2f}\n"
        else:
            trade_log += "No trades executed in the last 24 hours.\n"

        # 4. Construct and Send Email
        body = f"""
        ### SID BOT ADMIN HEARTBEAT ###
        Status: {status}

        Account Equity: ${equity:,.2f}
        Start of Day: ${start_of_day_balance:,.2f}
        Current Drawdown: {drawdown:.2%}

        {trade_log}

        System Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} EST
        """

        params = {
            "from": EMAIL_SENDER,
            "to": ADMIN_EMAIL,
            "subject": f"ADMIN: Bot Heartbeat - {status}",
            "text": body,
        }

        resend.Emails.send(params)
        print("âœ… Admin heartbeat sent via Resend.")

    except Exception as e:
        print(f"âŒ Failed to send admin heartbeat: {e}")


# --- SCANNER ENGINE ---

def run_advisor_scan():
    if not initialize_mt5(): return
    from prop_watchlist import WATCHLIST_SECTORS
    long_cands, short_cands = [], []
    sector_stats = {}
    equity = mt5.account_info().equity

    for sector, tickers in WATCHLIST_SECTORS.items():
        if not TRADE_SETTINGS.get(sector.upper(), False):
            sector_stats[sector] = 0
            continue

        count = 0
        for ticker in tickers:
            df = get_data(ticker)
            if df.empty or len(df) < 50: continue
            count += 1

            df.ta.rsi(length=14, append=True)
            df.ta.macd(append=True)
            macd_col = [c for c in df.columns if 'MACD_' in c][0]

            weekly = df.resample('W-FRI', on='timestamp').agg({'close': 'last'}).dropna()
            if len(weekly) < 2: continue
            weekly.ta.rsi(length=14, append=True)

            curr, prev = df.iloc[-1], df.iloc[-2]
            rsi_hist = df['RSI_14'].tail(SIGNAL_DAYS)

            # Long Entry Logic
            if (curr['RSI_14'] <= 45 and curr['RSI_14'] > prev['RSI_14'] and
                    curr[macd_col] > prev[macd_col] and (rsi_hist < 30).any() and
                    weekly.iloc[-1]['RSI_14'] > weekly.iloc[-2]['RSI_14']):

                if get_symbol_category(ticker) != "STOCKS" or is_earnings_safe(ticker):
                    sl = calculate_dynamic_stop(df, ticker, mt5.ORDER_TYPE_BUY)
                    info = mt5.symbol_info(ticker)
                    qty = (equity * RISK_PER_TRADE_PCT) / (abs(curr['close'] - sl) * info.trade_contract_size)
                    long_cands.append(
                        {'ticker': ticker, 'score': curr['RSI_14'], 'sl': sl, 'qty': round(qty, 2), 'df': df})

            # Short Entry Logic
            elif (curr['RSI_14'] >= 55 and curr['RSI_14'] < prev['RSI_14'] and
                  curr[macd_col] < prev[macd_col] and (rsi_hist > 70).any() and
                  weekly.iloc[-1]['RSI_14'] < weekly.iloc[-2]['RSI_14']):

                if get_symbol_category(ticker) != "STOCKS" or is_earnings_safe(ticker):
                    sl = calculate_dynamic_stop(df, ticker, mt5.ORDER_TYPE_SELL)
                    info = mt5.symbol_info(ticker)
                    qty = (equity * RISK_PER_TRADE_PCT) / (abs(curr['close'] - sl) * info.trade_contract_size)
                    short_cands.append(
                        {'ticker': ticker, 'score': -curr['RSI_14'], 'sl': sl, 'qty': round(qty, 2), 'df': df})

        sector_stats[sector] = count

    long_cands.sort(key=lambda x: x['score'])
    short_cands.sort(key=lambda x: abs(x['score']), reverse=True)
    send_advisor_email(long_cands, short_cands, sector_stats)
    mt5.shutdown()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='MT5 Prop Signal Advisor')
    parser.add_argument('--no-stocks', action='store_true', help='Disable Stocks')
    parser.add_argument('--no-forex', action='store_true', help='Disable Forex')
    parser.add_argument('--no-metals', action='store_true', help='Disable Metals')
    args = parser.parse_args()

    if args.no_stocks: TRADE_SETTINGS["STOCKS"] = False
    if args.no_forex: TRADE_SETTINGS["FOREX"] = False
    if args.no_metals: TRADE_SETTINGS["METALS"] = False

    run_advisor_scan()
